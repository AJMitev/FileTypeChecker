namespace FileTypeChecker.Tests
{
    using Exceptions;
    using NUnit.Framework;

    [TestFixture]
    public class MagicSequenceTests
    {
        [Test]
        [TestCase(new byte[] { 0x49, 0x44, 0x33 }, new byte[] { 0x49, 0x44, 0x33 }, 3)]
        [TestCase(new byte[] { 0x49, 0x44, 0x33, 0x44 }, new byte[] { 0x49, 0x44, 0x33 }, 3)]
        [TestCase(new byte[] { 0x49, 0x44, 0x33, 0x44 }, new byte[] { 0x44, 0x49, 0x44, 0x33 }, 0)]
        [TestCase(new byte[] { 0x44, 0x49, 0x44, 0x33, 0x44 }, new byte[] { 0x49, 0x44, 0x33 }, 0)]
        [TestCase(new byte[] { 0x52, 0x49, 0x46, 0x46, 0x42, 0x00, 0x42, 0x50, 0x56, 0x50, 0x38 }, new byte[] { 0x52, 0x49, 0x46, 0x46, 0x00, 0x45, 0x42, 0x50, 0x56, 0x50, 0x38 }, 4)]
        public void CountMatchingBytesShouldReturnNumbersOfMachtingBytes(byte[] magicBytes, byte[] compareBytes, int matching)
        {
            var sequence = new MagicSequence(magicBytes);
            var actual = sequence.CountMatchingBytes(compareBytes);

            Assert.AreEqual(matching, actual);
        }

        [Test]
        [TestCase(new byte[] { 0x52, 0x49, 0x46, 0x46, 0x00, 0x00, 0x00, 0x00, 0x57, 0x45, 0x42, 0x50, 0x56, 0x50, 0x38 }, new byte[] { 0x52, 0x49, 0x46, 0x46, 0x00, 0x00, 0x00, 0x00, 0x57, 0x45, 0x42, 0x50, 0x56, 0x50, 0x38 }, 11, 4, 5)]
        [TestCase(new byte[] { 0x52, 0x49, 0x46, 0x46, 0x00, 0x00, 0x00, 0x00, 0x57, 0x45, 0x42, 0x50, 0x56, 0x50, 0x38 }, new byte[] { 0x52, 0x49, 0x46, 0x46, 0x00, 0x42, 0x42, 0x00, 0x57, 0x45, 0x42, 0x50, 0x56, 0x50, 0x38 }, 11, 4, 5)]
        [TestCase(new byte[] { 0x52, 0x49, 0x46, 0x46, 0x00, 0x00, 0x00, 0x00, 0x57, 0x45, 0x42, 0x50, 0x56, 0x50, 0x38 }, new byte[] { 0x52, 0x46, 0x46, 0x00, 0x42, 0x42, 0x00, 0x57, 0x45, 0x42, 0x50, 0x56, 0x50, 0x38 }, 1, 4, 5)]
        [TestCase(new byte[] { 0x52, 0x49, 0x46, 0x46, 0x00, 0x00, 0x00, 0x00, 0x57, 0x45, 0x42, 0x50, 0x56, 0x50, 0x38 }, new byte[] { 0x52, 0x46, 0x46, 0x00, 0x42, 0x42, 0x00, 0x57, 0x45, 0x42, 0x50, 0x56, 0x50, 0x38 }, 1, 4, 3)]
        [TestCase(new byte[] { 0x52, 0x49, 0x00, 0x00, 0x00, 0x56, 0x50, 0x37 }, new byte[] { 0x52, 0x49, 0x00, 0x00, 0x00, 0x56, 0x50, 0x38 }, 4, 3, 2)]
        public void CountMatchingBytesShouldReturnNumbersOfMachtingBytesWhenThereIsSkipInTheMiddle(byte[] magicBytes, byte[] compareBytes, int matching, int bytesToSkip, int startFromIndex)
        {
            var sequence = new MagicSequence(magicBytes, bytesToSkip, startFromIndex);
            var actual = sequence.CountMatchingBytes(compareBytes);

            Assert.AreEqual(matching, actual);
        }

        [Test]
        [TestCase(new byte[] { 0x52, 0x49, 0x46, 0x46 }, new byte[] { 0x52, 0x49, 0x46, 0x46 }, true)]
        [TestCase(new byte[] { 0x52, 0x49, 0x46, 0x46 }, new byte[] { 0x52, 0x19, 0x46, 0x46 }, false)]
        [TestCase(new byte[] { 0x52, 0x19, 0x46, 0x41 }, new byte[] { 0x52, 0x19, 0x46, 0x46 }, false)]
        public void EqualsShouldReturnCorrectResult(byte[] first, byte[] second, bool expextedResult)
        {
            var magicBytes = new MagicSequence(first);
            var areEquals = magicBytes.Equals(second);

            Assert.IsTrue(areEquals == expextedResult);
        }

        [Test]
        public void EqualsShouldThrowInvalidInputExceptionIfTheArrayIsNull()
            => Assert.Throws<InvalidInputException>(() => new MagicSequence(new byte[] { 0x34, 0x24 }).Equals(null));

        [Test]
        public void EqualsShouldThrowInvalidInputExceptionIfTheArrayIsEmpty()
            => Assert.Throws<InvalidInputException>(() => new MagicSequence(new byte[] { 0x13 }).Equals(new byte[0]));
    }
}
